/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "vector_calc.h"
#include <stdbool.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <sys/wait.h>

typedef struct 
{
    int option;
    int *arr1;
    int *arr2;
    int size;
    double realNum;
} Request;

void error(char *msg)
{
    perror(msg);
    exit(1);
}

void print_vec(FILE* out,const double* vec,int n)
{
    for(int i=0;i<n;i++) fprintf(out,"%f\n",vec[i]);
}
int* init(int vec[],int n)
{
	vec = (int*) malloc(sizeof(int) * n);
	if (vec == NULL)
	{
		printf("Not enough memory...\n");
		exit(1);
	}
	return vec;
}
int setup_server(unsigned int portNo)
{
    struct sockaddr_in serverAddr;
    int serverfd;
    serverfd = socket(AF_INET, SOCK_STREAM, 0); 
    if (serverfd < 0) error("ERROR opening socket");
    bzero((char *) &serverAddr, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(portNo);
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    if (bind(serverfd, (struct sockaddr *) &serverAddr,sizeof(serverAddr)) < 0)  error("ERROR on binding");
    if(listen(serverfd,10) == -1) error("Error on listen");
	return serverfd;
}
void deserialize_request(char *buffer, int len, Request *req) {
    int pos = 0;
    memcpy(&(req->option), buffer + pos, sizeof(int));
    pos += sizeof(int);
    memcpy(&(req->size), buffer + pos, sizeof(int));
    pos += sizeof(int);
    memcpy(&(req->realNum), buffer + pos, sizeof(double));
    pos += sizeof(double);
    req->arr1 = (int*)malloc(req->size * sizeof(int));
    memcpy(req->arr1, buffer + pos, req->size * sizeof(int));
    pos += req->size * sizeof(int);
    req->arr2 = (int*)malloc(req->size * sizeof(int));
    memcpy(req->arr2, buffer + pos, req->size * sizeof(int));
}

bool process_request(const char *host,int connection)
{
	int buffLen,bytes;
	Request clientReq;
	CLIENT *clnt;
	int  *result_1;
	VecPair  dot_product_1_arg;

	RealVec2  *result_2;
	VecPair  average_1_arg;

	RealVec  *result_3;
	InputData  multiply_1_arg;
    printf("Connected.\n");
    int done = 0;
    do {
	    bytes = recv(connection, &buffLen,sizeof(int), 0);
        if (bytes < 1)
		{
			perror("No data read from socket\n");  
			printf("Connection will be closed\n");
            done = 1;
		}
        char* buffer = (char*)malloc(buffLen);
        recv(connection,buffer,buffLen,0);
        deserialize_request(buffer, buffLen, &clientReq); 	
        free(buffer);	
		#ifndef	DEBUG
			clnt = clnt_create (host, VECTOR_CALC_PROG, VECTOR_CALC_VERS, "udp");
			if (clnt == NULL) 
			{
			  clnt_pcreateerror (host);
			  exit (1);
			}
		#endif	/* DEBUG */ 
        switch (clientReq.option)
        {
        case 1:		
			dot_product_1_arg.X.X_len= dot_product_1_arg.Y.Y_len=dot_product_1_arg.n=clientReq.size;
			dot_product_1_arg.X.X_val= init(dot_product_1_arg.X.X_val,dot_product_1_arg.n);
			dot_product_1_arg.Y.Y_val= init(dot_product_1_arg.Y.Y_val,dot_product_1_arg.n);
			memcpy(dot_product_1_arg.X.X_val,clientReq.arr1,dot_product_1_arg.n*sizeof(int));
			memcpy(dot_product_1_arg.Y.Y_val,clientReq.arr2,dot_product_1_arg.n*sizeof(int));
			result_1 = dot_product_1(&dot_product_1_arg, clnt);
			free(dot_product_1_arg.X.X_val);free(dot_product_1_arg.Y.Y_val);
			if (result_1 == (int *) NULL) 
			{
				clnt_perror (clnt, "call failed");
			}
			else send(connection,result_1,sizeof(int),0);
		    break;
        case 2:
			average_1_arg.X.X_len= average_1_arg.Y.Y_len=average_1_arg.n=clientReq.size;
			average_1_arg.X.X_val = init(average_1_arg.X.X_val,average_1_arg.n);
			average_1_arg.Y.Y_val = init(average_1_arg.Y.Y_val,average_1_arg.n);
			memcpy(average_1_arg.X.X_val,clientReq.arr1,average_1_arg.n*sizeof(int));
			memcpy(average_1_arg.Y.Y_val,clientReq.arr2,average_1_arg.n*sizeof(int));
			result_2 = average_1(&average_1_arg, clnt);
			free(average_1_arg.X.X_val);free(average_1_arg.Y.Y_val);
			if (result_2 == (RealVec2 *) NULL) 
			{
				clnt_perror (clnt, "call failed");
			}
			else 
			{ 
				send(connection,&result_2->real[0],sizeof(double),0);
			    send(connection,&result_2->real[1],sizeof(double),0);
			}
			break;
        case 3:
			multiply_1_arg.VP.X.X_len= multiply_1_arg.VP.Y.Y_len=multiply_1_arg.VP.n=clientReq.size;
			multiply_1_arg.VP.X.X_val = init(multiply_1_arg.VP.X.X_val,multiply_1_arg.VP.n);
			multiply_1_arg.VP.Y.Y_val = init(multiply_1_arg.VP.Y.Y_val,multiply_1_arg.VP.n);
			memcpy(multiply_1_arg.VP.X.X_val,clientReq.arr1,multiply_1_arg.VP.n*sizeof(int));
			memcpy(multiply_1_arg.VP.Y.Y_val,clientReq.arr2,multiply_1_arg.VP.n*sizeof(int));
			multiply_1_arg.r=clientReq.realNum;
			result_3 = multiply_1(&multiply_1_arg, clnt);
			free(multiply_1_arg.VP.X.X_val);free(multiply_1_arg.VP.Y.Y_val);
			if (result_3 == (RealVec *) NULL) 
			{
				clnt_perror (clnt, "call failed");
			}
			else send(connection,result_3->real.real_val,result_3->n*sizeof(double),0);
			free(result_3->real.real_val);
            break;
		case 4:
		    free(clientReq.arr1);
			free(clientReq.arr2);
			done=1;
			break;
        default:
            break;
        }
		#ifndef	DEBUG
		clnt_destroy (clnt);
		#endif	 /* DEBUG */ 
    } while (!done);
    return true;
}

int main (int argc, char *argv[])
{
	if (argc != 3) {
        printf("Usage: %s <rpc_server_hostname> <rpc_server_port>\n", argv[0]);
        exit(1);
    }
	char *host;
	host = argv[1];
    int serverfd, connection, clientLen;
	unsigned int portNum,children=0;
	portNum = atoi(argv[2]);
	if ( (serverfd = setup_server (portNum)) < 0)  error("Failed to set up server");
    struct sockaddr_in  clientAddr;
    
	bool running = true;

     while(running) 
	{
     	printf("Waiting for a connection...\n");
     	clientLen = sizeof(clientAddr);
     	connection = accept(serverfd, (struct sockaddr *) &clientAddr, &clientLen);
     	if (connection < 0) error("ERROR on accept");
        pid_t child = fork();
		if (child == 0) { // child process
            close(serverfd);
            running = process_request(host,connection);
            exit(0);
        } 
        else if (child > 0) // parent process
        {    
			close(connection);
             children++;
	         while (children)
			 {
             	pid_t procId=waitpid((pid_t) -1, NULL, WNOHANG);
	         	if (procId<0) error("waitpid error");
	         	else if (procId==0) break;
             }			
        }
        else running = false; // Failed to fork
    }  
    shutdown(serverfd,SHUT_RDWR);  
    close(serverfd);
	return 0;
}
